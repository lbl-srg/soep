

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>6. Numerical Methods of the Master Algorithm &#8212; Spawn of EnergyPlus</title>
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap_custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap_custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom-sphinx.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/lbl-icon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Benchmarks" href="benchmarks.html" />
    <link rel="prev" title="5. Software Architecture" href="softwareArchitecture.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default ">
    <div class="container-fluid">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><img src="_static/spawn_icon_darkbluetxhighres.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="index.html">Index</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preample.html">1. Preample</a><ul>
<li class="toctree-l2"><a class="reference internal" href="preample.html#purpose-of-the-document">1.1. Purpose of the Document</a></li>
<li class="toctree-l2"><a class="reference internal" href="preample.html#contributors">1.2. Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="download.html">2. Download</a><ul>
<li class="toctree-l2"><a class="reference internal" href="download.html#software">2.1. Software</a></li>
<li class="toctree-l2"><a class="reference internal" href="download.html#publications">2.2. Publications</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="conventions.html">3. Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="requirements.html">4. Requirements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="requirements.html#openstudio-integration">4.1. OpenStudio integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="requirements.html#mathematics">4.2. Mathematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="requirements.html#fmu-requirements">4.3. FMU Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="requirements.html#qss-implementation">4.4. QSS Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="requirements.html#master-algorithm">4.5. Master Algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="softwareArchitecture.html">5. Software Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="softwareArchitecture.html#overall-software-architecture">5.1. Overall software architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="softwareArchitecture.html#coupling-of-energyplus-with-modelica">5.2. Coupling of EnergyPlus with Modelica</a></li>
<li class="toctree-l2"><a class="reference internal" href="softwareArchitecture.html#integration-of-qss-solver-with-optimica">5.3. Integration of QSS solver with OPTIMICA</a></li>
<li class="toctree-l2"><a class="reference internal" href="softwareArchitecture.html#integration-with-openstudio">5.4. Integration with OpenStudio</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Numerical Methods of the Master Algorithm</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#time-integration">6.1. Time Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algebraic-loops">6.2. Algebraic Loops</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="benchmarks.html">7. Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgments.html">8. Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">10. References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">6. Numerical Methods of the Master Algorithm</a><ul>
<li><a class="reference internal" href="#time-integration">6.1. Time Integration</a><ul>
<li><a class="reference internal" href="#qss1">6.1.1. QSS1</a></li>
<li><a class="reference internal" href="#qss2">6.1.2. QSS2</a></li>
<li><a class="reference internal" href="#qss3">6.1.3. QSS3</a></li>
<li><a class="reference internal" href="#discussion-of-qss">6.1.4. Discussion of QSS</a></li>
<li><a class="reference internal" href="#liqss">6.1.5. LIQSS</a></li>
<li><a class="reference internal" href="#discussion-of-liqss">6.1.6. Discussion of LIQSS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#algebraic-loops">6.2. Algebraic Loops</a><ul>
<li><a class="reference internal" href="#software-requirements-for-efficient-implementation-of-newton-raphson-method-for-algebraic-loops">6.2.1. Software Requirements for Efficient Implementation of Newton-Raphson Method for Algebraic Loops</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="softwareArchitecture.html" title="Previous Chapter: 5. Software Architecture"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 5. Software A...</span>
    </a>
  </li>
  <li>
    <a href="benchmarks.html" title="Next Chapter: 7. Benchmarks"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">7. Benchmarks &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

<!--
          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
-->
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="numerical-methods-of-the-master-algorithm">
<h1>6. Numerical Methods of the Master Algorithm<a class="headerlink" href="#numerical-methods-of-the-master-algorithm" title="Permalink to this headline">Â¶</a></h1>
<p>This section describes the numerical methods that are used by the master algorithm.</p>
<p>First, we note that conventional continuous time integration algorithms have the following fundamental properties in common <a class="reference internal" href="zreferences.html#cellierkofman2006" id="id1">[CK06]</a>: Given a time <span class="math notranslate nohighlight">\(t_{k+1}\)</span>, a polynomial approximation is performed to determine the values
of all state variables at that time instant. If an error estimate is too large, the computation is repeated with a shorter time step. If an event happened, an iteration takes place across
all states to determine when the event occurred. At the event, the approximations of the higher-order derivatives, which are the basis for multi-step methods, become invalid.
Hence multi-step methods need to be restarted with a low-order method. This is very expensive as it involves a global event iteration followed by an integrator reset to a low order method.
As event iteration is computationally expensive, and as our models will have a large number of state events, we will use a different integration method based on the <em>Quantized State System (QSS)</em> representation.</p>
<div class="section" id="time-integration">
<h2>6.1. Time Integration<a class="headerlink" href="#time-integration" title="Permalink to this headline">Â¶</a></h2>
<p>QSS methods follow entirely different approach:
Let <span class="math notranslate nohighlight">\(t_k\)</span> be the current time. We ask each state individually at what time <span class="math notranslate nohighlight">\(t_{k+1}\)</span> it will deviate more than a quantum <span class="math notranslate nohighlight">\(\Delta q&gt; 0\)</span> from its current value.
This is a fundamentally different approach as the state space is discretized, rather than time, and all communication occurs through discrete events.
Furthermore, when a state variable changes to a new quantization level, the change need only be communicated to other components whose derivatives depend on that state,
hence communication is local. We thus selected for the SOEP QSS as our integration methods.</p>
<p>QSS algorithms are new methods that are fundamentally different from standard DAE or ODE solvers.
The volume of literature about QSS methods is today where ODE solvers were about 30 years ago.
QSS methods have interesting properties as they naturally lead to asynchronous integration with minimal communication among state variables.
They also handle state events explicitly without requiring an iteration in time to solve zero-crossing functions.</p>
<p>The first order QSS method, QSS1, first appeared in the literature in 1998 <a class="reference internal" href="zreferences.html#zeiglerlee1998" id="id2">[ZL98]</a>. QSS1 methods have been extended to second and third order methods (QSS2, QSS3).
On non-stiff problems, QSS3 has been shown to be significantly faster than QSS, and in some cases were faster than DASSL in Dymola <a class="reference internal" href="zreferences.html#florosetal2011-1" id="id3">[FBCK11]</a>.
To address performance issues observed in QSS, the class of Linear Implicit QSS methods (LIQSS) have been developed for stiff systems <a class="reference internal" href="zreferences.html#kofman2006-1" id="id4">[Kof06]</a> <a class="reference internal" href="zreferences.html#migonibortolottokofmancellier2013-1" id="id5">[MBKC13]</a>.
For stiff systems, the 3rd order implementation of LIQSS seems to perform best as shown in <a class="reference internal" href="#fig-liqss-migoni"><span class="std std-numref">Fig. 6.1</span></a>, which is from <a class="reference internal" href="zreferences.html#migonibortolottokofmancellier2013-1" id="id6">[MBKC13]</a>.</p>
<div class="figure align-default" id="id14">
<span id="fig-liqss-migoni"></span><a class="reference internal image-reference" href="_images/liqss.png"><img alt="_images/liqss.png" src="_images/liqss.png" style="width: 1396.8000000000002px; height: 728.8000000000001px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.1 </span>: LIQSS method have linear growth of computing time, whereas ode15 (MATLAB) and esdirk23a (Dymola) have cubic growth.</span><a class="headerlink" href="#id14" title="Permalink to this image">Â¶</a></p>
</div>
<p>Over the past years, different classes of QSS algorithms have been implemented. The next section describes how these algorithms differ from one another.
We also give insights into which algorithms appear to be suitable for the SOEP.</p>
<div class="section" id="qss1">
<h3>6.1.1. QSS1<a class="headerlink" href="#qss1" title="Permalink to this headline">Â¶</a></h3>
<p>We will first discuss QSS1 and then show how it has been extended to higher order and implicit QSS methods.
Consider the following ODE</p>
<div class="math notranslate nohighlight" id="equation-eq-ode">
<span class="eqno">(6.1)<a class="headerlink" href="#equation-eq-ode" title="Permalink to this equation">Â¶</a></span>\[\dot x(t) = f (x(t), u(t)),\]</div>
<p>with <span class="math notranslate nohighlight">\(t \in [t_0, \, t_f]\)</span>, and initial conditions <span class="math notranslate nohighlight">\(x(t_0) = x_0\)</span>,
where <span class="math notranslate nohighlight">\(x(t) \in \Re^n\)</span> is the state vector and <span class="math notranslate nohighlight">\(u(t) \in \Re^m\)</span> is the input vector. For simplicity, suppose <span class="math notranslate nohighlight">\(u(\cdot)\)</span> is piece-wise constant.
The QSS1 method solves analytically an approximate ODE, which is called QSS, of the form</p>
<div class="math notranslate nohighlight" id="equation-eq-odeqss">
<span class="eqno">(6.2)<a class="headerlink" href="#equation-eq-odeqss" title="Permalink to this equation">Â¶</a></span>\[\dot x(t) = f (q(t), u(t)),\]</div>
<p>where <span class="math notranslate nohighlight">\(q(t)\)</span> is a vector of quantized values of the state <span class="math notranslate nohighlight">\(x(t)\)</span>. Each component <span class="math notranslate nohighlight">\(q_i(t)\)</span>
of <span class="math notranslate nohighlight">\(q(t)\)</span> follows a piecewise constant trajectory, related with the corresponding component <span class="math notranslate nohighlight">\(x_i(t)\)</span> by a hysteretic
quantization function. The hysteretic
quantization function is defined as follows:
For some <span class="math notranslate nohighlight">\(K \in \mathbb N_+\)</span>,
let <span class="math notranslate nohighlight">\(j \in \{0, \ldots, K-1\}\)</span> denote the counter for the time intervals.
Then, for <span class="math notranslate nohighlight">\(t_j \le t &lt; t_{j+1}\)</span>,
the hysteretic quantization function is defined as</p>
<div class="math notranslate nohighlight" id="equation-eq-hysqua1stord">
<span class="eqno">(6.3)<a class="headerlink" href="#equation-eq-hysqua1stord" title="Permalink to this equation">Â¶</a></span>\[\begin{split}     q_i (t) =
     \begin{cases}
     x_i(t), &amp; \text{if } |x_i (t)-q_i(t^{-})| = \Delta q_i, \\
     q_i(t_j), &amp; \text{otherwise},
     \end{cases}\end{split}\]</div>
<p>with initial condition <span class="math notranslate nohighlight">\(q_i(t_0) = x_i(t_0)\)</span>,
where the sequence <span class="math notranslate nohighlight">\(\{t_{j}\}_{j=0}^{K-1}\)</span> is constructed as</p>
<div class="math notranslate nohighlight">
\[t_{j+1} = \min \{t \in \Re \, | \, t &gt; t_j, \,  |x_i(t_j) - x_i(t)| = \Delta q_i \}.\]</div>
<p>Thus, the component <span class="math notranslate nohighlight">\(q_i(t)\)</span> changes its state when it differs from <span class="math notranslate nohighlight">\(x_i(t)\)</span> by <span class="math notranslate nohighlight">\(\pm\Delta q_i\)</span>.
<a class="reference internal" href="#fig-qss1-example"><span class="std std-numref">Fig. 6.2</span></a> shows an example of a quantization function for QSS1.</p>
<div class="figure align-default" id="id15">
<span id="fig-qss1-example"></span><a class="reference internal image-reference" href="_images/qss1.png"><img alt="_images/qss1.png" src="_images/qss1.png" style="width: 900.0px; height: 551.4px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.2 </span>: Example of quantization function for QSS1.</span><a class="headerlink" href="#id15" title="Permalink to this image">Â¶</a></p>
</div>
<p><strong>Example</strong></p>
<p>For illustration, consider the following differential equation where on the left,
we have the original form, and on the right, we have its QSS form. Here, we took the simplest quantization function,
e.g, the ceiling function <span class="math notranslate nohighlight">\(q(x)=\lceil{x}\rceil = \arg \min_{z \in \mathbb Z} \{ x \le z \}\)</span>, but in practice,
finer spacing with hysteresis is used for higher accuracy and to avoid chattering. Consider</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}[c]
\dot x_1(t) &amp; = - x_1(t) \\
\dot x_2(t) &amp; = - 2 \, x_1(t) \\
\dot x_3(t) &amp; = - 2 \, \left( 2 \, x_2(t) + x_3(t) \right) \\
x(0) &amp; = (10, 10, 10)
\end{aligned}
\qquad\xrightarrow{\text{QSS1}}\qquad
\begin{aligned}[c]
\dot \chi_1(t) &amp; = - \lceil{\chi_1(t)}\rceil \\
\dot \chi_2(t) &amp; = - 2 \, \lceil{\chi_1(t)}\rceil \\
\dot \chi_3(t) &amp; = - 2 \, \left(  2 \, \lceil{\chi_2(t)}\rceil + \lceil{\chi_3(t)}\rceil \right) \\
\chi(0) &amp; = (10, 10, 10)
\end{aligned}\end{split}\]</div>
<p><a class="reference internal" href="#fig-qss-ceil-example"><span class="std std-numref">Fig. 6.3</span></a> shows the time series of the solution of the differential equation computed by QSS1.</p>
<div class="figure align-default" id="id16">
<span id="fig-qss-ceil-example"></span><a class="reference internal image-reference" href="_images/qssCeil.png"><img alt="_images/qssCeil.png" src="_images/qssCeil.png" style="width: 1100.0px; height: 400.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.3 </span>: Time series computed by QSS1 for <span class="math notranslate nohighlight">\(t \in [0, 0.1]\)</span>.</span><a class="headerlink" href="#id16" title="Permalink to this image">Â¶</a></p>
</div>
<p>The computation is as follows:
In QSS, each state can be integrated asynchronously until its right-hand side changes.
Therefore, we can compute directly the first transitions as <span class="math notranslate nohighlight">\(\chi_1(0.1) = 9\)</span>, <span class="math notranslate nohighlight">\(\chi_2(0.05) = 9\)</span>, <span class="math notranslate nohighlight">\(\chi_3(0.01667) = 9\)</span>. We can keep integrating <span class="math notranslate nohighlight">\(\chi_3(\cdot)\)</span> until its input <span class="math notranslate nohighlight">\(\chi_2(\cdot)\)</span> changes, which will be at <span class="math notranslate nohighlight">\(t=0.05\)</span>. Thus, we compute <span class="math notranslate nohighlight">\(\chi_3(0.0339) = 8\)</span>. The next transition of <span class="math notranslate nohighlight">\(\chi_3(\cdot)\)</span> would be at <span class="math notranslate nohighlight">\(t=0.0518\)</span>. But <span class="math notranslate nohighlight">\(\chi_2(\cdot)\)</span> transitions from <span class="math notranslate nohighlight">\(10\)</span> to <span class="math notranslate nohighlight">\(9\)</span> at <span class="math notranslate nohighlight">\(t=0.05\)</span> so we can not integrate beyond that. Hence, we compute the next potential transition of <span class="math notranslate nohighlight">\(\chi_3(\cdot)\)</span> (from <span class="math notranslate nohighlight">\(8\)</span> to <span class="math notranslate nohighlight">\(7\)</span>) as <span class="math notranslate nohighlight">\(t = 0.05190 = \arg \min \{\Delta \in \Re_0^+ \, | 7 = 8 + \int_{0.0339}^{0.05} (-2 \, (2 \cdot 10 + 8) \, ds + \int_{0.05}^{\Delta} (-2 \, (2 \cdot 9+8)) \, ds\}\)</span>. Hence, <span class="math notranslate nohighlight">\(\chi_3(\cdot)\)</span> will transition next at <span class="math notranslate nohighlight">\(t=0.05190\)</span> provided that its input does not change within this time. The input wonât change because the next transition of <span class="math notranslate nohighlight">\(\chi_2(\cdot)\)</span> will be <span class="math notranslate nohighlight">\(\chi_2(0.1) = 8\)</span>. Therefore, we integrate <span class="math notranslate nohighlight">\(\chi_3(\cdot)\)</span> until <span class="math notranslate nohighlight">\(t=0.1\)</span>, at which time <span class="math notranslate nohighlight">\(\chi_1(\cdot)\)</span> and <span class="math notranslate nohighlight">\(\chi_2(\cdot)\)</span> transition.</p>
</div>
<div class="section" id="qss2">
<h3>6.1.2. QSS2<a class="headerlink" href="#qss2" title="Permalink to this headline">Â¶</a></h3>
<p>We will now describe the second order QSS2 method.
This method replaces the simple hysteretic quantization function of QSS1
<a class="reference internal" href="#equation-eq-hysqua1stord">(6.3)</a> with a first order-quantizer. This leads,
for <span class="math notranslate nohighlight">\(t_j \leq t &lt; t_{j+1}\)</span>, to</p>
<div class="math notranslate nohighlight">
\[\begin{split}q_i(t) =
\begin{cases}
x_i(t), &amp; \text{if } |x_i(t)-q_i(t^{-})| = \Delta q_i, \\
q_i(t_j) + m_{ij} (t-t_j), &amp; \text{otherwise},
\end{cases}\end{split}\]</div>
<p>with initial condition <span class="math notranslate nohighlight">\(q_i(t_0) = x_i(t_0)\)</span>,
where the sequence <span class="math notranslate nohighlight">\(\{t_{j}\}_{j=0}^{K-1}\)</span> is constructed as</p>
<div class="math notranslate nohighlight">
\[t_{j+1} = \min \{t \in \Re \, | \, t &gt; t_j, \,  |x_i(t_j) + m_{ij} (t-t_j) - x_i(t)| = \Delta q_i \},\]</div>
<p>with the slope <span class="math notranslate nohighlight">\(m_{ij}\)</span> defined as <span class="math notranslate nohighlight">\(m_{i0}=0\)</span> and <span class="math notranslate nohighlight">\(m_{ij}= \dot x_i(t_j^-)\)</span> for <span class="math notranslate nohighlight">\(j \in \{1, \ldots, K-1\}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For <span class="math notranslate nohighlight">\(m_{ij}\)</span>, the limit from below <span class="math notranslate nohighlight">\(\dot x_i(t_j^-)\)</span> is used.</p>
</div>
<p>The figure below shows an example of a quantization function for QSS2.</p>
<div class="figure align-default" id="id17">
<a class="reference internal image-reference" href="_images/qss2.png"><img alt="_images/qss2.png" src="_images/qss2.png" style="width: 870.0px; height: 551.4px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.4 </span>: Example of quantization function for QSS2.</span><a class="headerlink" href="#id17" title="Permalink to this image">Â¶</a></p>
</div>
</div>
<div class="section" id="qss3">
<h3>6.1.3. QSS3<a class="headerlink" href="#qss3" title="Permalink to this headline">Â¶</a></h3>
<p>In QSS3, the trajectories of <span class="math notranslate nohighlight">\(x_i(t)\)</span> and <span class="math notranslate nohighlight">\(q_i(t)\)</span> are related by a second order quantization function.
This leads, for <span class="math notranslate nohighlight">\(t_j \leq t &lt; t_{j+1}\)</span>, to</p>
<div class="math notranslate nohighlight">
\[\begin{split}q_i(t) =
\begin{cases}
x_i(t), &amp; \text{if } |x_i(t)-q_i(t^{-})| = \Delta q_i, \\
q_i(t_j) + m_{ij} (t-t_j) + p_{ij} (t-t_j)^2, &amp; \text{otherwise},
\end{cases}\end{split}\]</div>
<p>with initial condition <span class="math notranslate nohighlight">\(q_i(t_0) = x_i(t_0)\)</span>,
where the sequence <span class="math notranslate nohighlight">\(\{t_{j}\}_{j=0}^{K-1}\)</span> is constructed as</p>
<div class="math notranslate nohighlight">
\[t_{j+1} = \min \{t \in \Re \, | \, t &gt; t_j, \,  |x_i(t_j) + m_{ij} (t-t_j) + p_{ij} (t-t_j)^2 - x_i(t)| = \Delta q_i \},\]</div>
<p>with the slopes defined as
<span class="math notranslate nohighlight">\(m_{i0}=0\)</span> and <span class="math notranslate nohighlight">\(m_{ij}= \dot x_i(t_j^-)\)</span>,
for <span class="math notranslate nohighlight">\(j \in \{1, \ldots, K-1\}\)</span>, for the first order term, and
<span class="math notranslate nohighlight">\(p_{i0}=0\)</span> and <span class="math notranslate nohighlight">\(p_{ij}= \dot m_{ij}\)</span> for the second order term.</p>
</div>
<div class="section" id="discussion-of-qss">
<h3>6.1.4. Discussion of QSS<a class="headerlink" href="#discussion-of-qss" title="Permalink to this headline">Â¶</a></h3>
<p>QSS1, QSS2, and QSS3 are efficient for the simulation of non-stiff ODEs.</p>
<p>The number of integration steps of QSS1 is inversely proportional
to the quantum. For QSS2, it is inversely proportional to the square root of the quantum. For QSS3, it is inversely proportional to the cubic root of the quantum. See <a class="reference internal" href="zreferences.html#kofman2006-1" id="id7">[Kof06]</a> for a derivation.</p>
<p>However, they have been shown to exhibit oscillatory behavior, with high computing time, if applied to stiff ODEs <a class="reference internal" href="zreferences.html#migonibortolottokofmancellier2013-1" id="id8">[MBKC13]</a>.
In <a class="reference internal" href="zreferences.html#migonibortolottokofmancellier2013-1" id="id9">[MBKC13]</a>, they were extended to LIQSS methods.
As building simulation models can be stiff, we will now present these methods.</p>
</div>
<div class="section" id="liqss">
<h3>6.1.5. LIQSS<a class="headerlink" href="#liqss" title="Permalink to this headline">Â¶</a></h3>
<p>We will now focus our discussion on LIQSS methods, which seem to be the most applicable classes of QSS methods for building simulation.
We will start our discussion with the first order LIQSS (LIQSS1) and expand the discussion to higher order LIQSS methods. The basic idea of LIQSS1 is to select the value of <span class="math notranslate nohighlight">\(q_i(t)\)</span> so that <span class="math notranslate nohighlight">\(x_i(t)\)</span> approaches <span class="math notranslate nohighlight">\(q_i(t)\)</span>.
This implies that <span class="math notranslate nohighlight">\((q_i(t)-x_i(t)) \, \dot {x}_i(t) \geq 0\)</span> for <span class="math notranslate nohighlight">\(t_j \leq t &lt; t_{j+1}\)</span>.
Given the ODE defined in <a class="reference internal" href="#equation-eq-ode">(6.1)</a>, LIQSS1 approximates it by <a class="reference internal" href="#equation-eq-odeqss">(6.2)</a>, where each <span class="math notranslate nohighlight">\(q_i(t)\)</span> is defined in <a class="reference internal" href="zreferences.html#migonikofman2007-1" id="id10">[MK07]</a> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}q_i(t) =
\begin{cases}
\underline{q}_i(t), &amp; \text{if } f_{i}(q(t), u(t)) \,(\underline{q}_i(t) - x_{i}(t)) \geq 0, \\
\bar{q}_i(t), &amp; \text{if } f_{i}(q(t), u(t)) \,(\bar{q}_i(t) - x_{i}(t)) \geq 0 \land f_{i}(q(t), u(t)) \,(\underline{q}_i(t) - x_{i}(t)) &lt; 0, \\
\tilde{q}_i(t), &amp; \text{otherwise},
\end{cases}\end{split}\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[\begin{split}\underline{q}_i(t) &amp; =
    \begin{cases}
       \underline{q}_i(t^-) - \Delta q_i, &amp; \text{if } x_i(t) - \underline{q}_i(t^-) \le 0, \\
       \underline{q}_i(t^-) + \Delta q_i, &amp; \text{if } x_i(t) - \underline{q}_i(t^-) \ge 2 \, \Delta q_i, \\
       \underline{q}_i(t^-),              &amp; \text{otherwise,}\\
    \end{cases}\\
\bar q_i(t) &amp; = \underline{q}_i(t) + 2 \, \Delta q_i, \\
\tilde q_i(t) &amp; = \begin{cases}
                \bar q_i(t) - \frac{1}{A_{i,i}} f_i(\bar {q}^i(t), u(t)), &amp; \text{if } A_{i,i} \not = 0,\\
                     q_i(t^-),                                              &amp; \text{otherwise,}\\
                  \end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(A_{i,i}\)</span> is an estimate of the <span class="math notranslate nohighlight">\(i\)</span>-th diagonal element of the Jacobian.
For its computation, and for how to compute
<span class="math notranslate nohighlight">\(\bar {q}^i(t)\)</span>, we refer to <a class="reference internal" href="zreferences.html#migonikofman2007-1" id="id11">[MK07]</a>.</p>
<p>Higher order LIQSS methods (e.g. LIQSS2, LIQSS3) combine the ideas of higher order QSS methods and LIQSS. Reference <a class="reference internal" href="zreferences.html#migonibortolottokofmancellier2013-1" id="id12">[MBKC13]</a> gives a detailed formal definition of such methods.
Rather than using the first order condition, the <span class="math notranslate nohighlight">\(N\)</span>-th order method LIQSSN uses <span class="math notranslate nohighlight">\((q_i(t)-x_i(t)) \, x_i^{(N)}(t) \geq 0\)</span>, where <span class="math notranslate nohighlight">\(x_i^{(N)}: \Re \rightarrow \Re\)</span> is the <span class="math notranslate nohighlight">\(N\)</span>-th order derivative of <span class="math notranslate nohighlight">\(x_i( \cdot)\)</span> with respect to time.</p>
</div>
<div class="section" id="discussion-of-liqss">
<h3>6.1.6. Discussion of LIQSS<a class="headerlink" href="#discussion-of-liqss" title="Permalink to this headline">Â¶</a></h3>
<p>LIQSS methods are efficient for stiff systems where the stiffness is reflected in large diagonal elements of the Jacobian matrix. This is due to the fact that LIQSS solvers avoid fast oscillations by using information derived from the diagonal of the Jacobian matrix. When stiffness is not due to the diagonal elements of the Jacobian matrix, then LIQSS can also exhibit oscillatory behavior <a class="reference internal" href="zreferences.html#migonibortolottokofmancellier2013-1" id="id13">[MBKC13]</a>.</p>
</div>
</div>
<div class="section" id="algebraic-loops">
<span id="sec-alg-loops"></span><h2>6.2. Algebraic Loops<a class="headerlink" href="#algebraic-loops" title="Permalink to this headline">Â¶</a></h2>
<p>This section discusses algebraic loops which can occur when modeling systems with feedback. In block diagrams, algebraic loops occur when the input of a block with direct feedthrough
is connected to the output of the same block, either directly, or by a feedback path through other blocks which all have direct feedthrough.</p>
<p>Algebraic loops are generally introduced when the dynamics of a component is approximated by its steady-state solution. For the SOEP,
subsystems that form algebraic loops include:</p>
<ol class="arabic simple">
<li><p>The infrared radiation network within a thermal zone.
This is not a problem as this system of equations is likely to be
contained inside an FMU. Hence, an FMU can output the solution to
this system of algebraic equations.</p></li>
<li><p>Flow networks such as a water loop. Algebraic loops can be formed
for the energy balance, mass balance and the pressure network. For
the energy and mass balance, these loops can be eliminated by
adding a transport delay that approximates the travel time of the
fluid inside the pipe. For the pressure network, an approximation
through the speed of sound is not suited as this would lead to very
fast transients. Therefore, we will need a means to solve systems
of algebraic equations that are formed by coupling multiple FMUs
with direct feedthrough.</p></li>
</ol>
<p>Such algebraic loops are generally solved using Newton-Raphson type
algorithms. In the next section, we describe the requirements
of these methods.</p>
<div class="section" id="software-requirements-for-efficient-implementation-of-newton-raphson-method-for-algebraic-loops">
<h3>6.2.1. Software Requirements for Efficient Implementation of Newton-Raphson Method for Algebraic Loops<a class="headerlink" href="#software-requirements-for-efficient-implementation-of-newton-raphson-method-for-algebraic-loops" title="Permalink to this headline">Â¶</a></h3>
<p>The following requirements are needed by SOEP FMUs to ensure that they can be efficiently solved using the Newton-Raphson method:</p>
<ol class="arabic simple">
<li><p>FMUs need to provide information about their input dependencies.
This information is stored in the model description file of the FMU
as output dependency under the element <code class="docutils literal notranslate"><span class="pre">&lt;ModelStructure&gt;</span></code>. In
FMI 2.0, this data is specified as optional.
For SOEP, we require the output dependency to be declared as the
master requires it to determine the existence and location of
algebraic loops.
Note that a connection between input and output only causes an
algebraic loop if the output depends algebraically on the input.
Integrators, however, break algebraic loops.</p></li>
<li><p>FMUs need to provide derivatives of their outputs with respect to
their inputs. This information is needed by the Newton-Raphson
method. The Newton-Raphson
method finds the root of the residual function <span class="math notranslate nohighlight">\(f(x) = y-x\)</span>.
The root of this function is calculated iteratively as
<span class="math notranslate nohighlight">\(x_{k+1}=x_k -{y_k}/{f'(x_k)}\)</span> with
<span class="math notranslate nohighlight">\(f'(x) = {df(x)}/{dx}\)</span>. If the derivative with respect to the
input cannot be provided, then the derivative would need to be
approximated numerically. This is computationally costly and
less robust than providing derivative functions.</p></li>
</ol>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
  
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright (c) All rights reserved.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.<br/>
    </p>
  </div>
</footer>

  </body>
</html>